from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import cooler
import matplotlib as mpl
import pandas as pd
import numpy as np

my23colors = ['#53868B','#00F5FF','#C1FFC1','#0000FF','#7B68EE',
                  '#CDCD00','#FFF68F','#CD9B1D','#8B658B','#FF6A6A','#8B3A3A',
                  '#1E90FF','#FF69B4','#8DB6CD','#CAE1FF','#EECFA1','#8B7B8B',
                  '#4F4F4F','#FF4500','#BC8F8F','#FFA500','#228B22','#8B4513']


def get_regionsMat(
        coolMat: cooler.Cooler, 
        regions: list = ["6:119940450-123940450", "18:12432736-8400000", "4:10500000-10000000"], 
        balance: bool = False) -> pd.DataFrame:
    """Extract a set of regions matrix from the cool format Hi-C matrix.

    The extracted matrix will splice intra and Inter region interaction according to 
        the given order and direction of the regions.

    Args:
        coolMat (cooler.Cooler): cool format Hi-C matrix (https://github.com/open2c/cooler)
        regions (list): Region format as ["6:119940450-123940450", "18:12432736-8432736"]
        balance (bool): The 'balance' parameters of coolMat.matrix(balance=False).fetch('chr6:119940450-123940450')

    Returns:
        np.array: region matrix
        pd.DataFrame: Region interaction matrix

    """

    rdf = pd.DataFrame(regions)
    rdf.columns = ["region"]
    sp_resions = rdf["region"].apply(split_region)
    rdf["chrom"] = [i[0] for i in sp_resions]
    rdf["start"] = [int(i[1]) for i in sp_resions]
    rdf["end"] = [int(i[2]) for i in sp_resions]

    rdf["reverse"] = False
    needRevdf = rdf[rdf["end"] < rdf["start"]]
 
    rdf.loc[needRevdf.index, "reverse"] = True
    rdf["regionForCool"] = rdf["region"]
    rdf.loc[needRevdf.index, "regionForCool"] = needRevdf["chrom"] + ":" + needRevdf["end"].apply(str) + "-" + needRevdf["start"].apply(str)

    region_mat_dic = {}

    for regin1 in rdf["regionForCool"]:
        for regin2 in rdf["regionForCool"]:
            region_mat_dic["{0}__{1}".format(regin1, regin2)] = coolMat.matrix(balance=balance).fetch(regin1, regin2)
            #rdf.loc[]

    for i, row in rdf.iterrows():
        if row["reverse"] == True:
            for region_2 in rdf["regionForCool"]:
                region_mat_dic["{0}__{1}".format(row["regionForCool"], region_2)] = np.flip(region_mat_dic["{0}__{1}".format(row["regionForCool"], region_2)], 0)
                region_mat_dic["{1}__{0}".format(row["regionForCool"], region_2)] = np.flip(region_mat_dic["{1}__{0}".format(row["regionForCool"], region_2)], 1)

                
    hstack_list = [None]*rdf.shape[0]
    vstack_list = [None]*rdf.shape[0]
    
    for i, regin1 in enumerate(rdf["regionForCool"]):
        for ii, regin2 in enumerate(rdf["regionForCool"]):
            hstack_list[ii] = region_mat_dic["{0}__{1}".format(regin1, regin2)]
        
        vstack_list[i] = np.hstack(tuple(hstack_list))
                          
    dataframe = np.vstack(tuple(vstack_list))
    
    #### 
    rdf["len"] = 0
    rdf_cp = rdf.copy()
    for i, row in rdf_cp.iterrows():
        rdf.loc[i, "len"] = region_mat_dic["{0}__{1}".format(row["regionForCool"], row["regionForCool"])].shape[0]
        
    return dataframe, rdf
        


def cmap_triview(axes, 
    coolMat, 
    matBalance=False, 
    regions=["chr6:119940450-123940450", "chr18:8432736-12432736"], 
    width=6, height=3, 
    cmap=mpl.cm.YlGnBu, 
    showXticks=True, title=None, ymax=None, 
    logData=True):
    """Create a heatmap of the lower triangle of a pairwise correlation
    matrix of all pairs of columns in the given dataframe. The heatmap
    triangle is rotated 45 degrees clockwise and drawn on the given axes.
    Parameters
    ----------
    dataframe : pandas.DataFrame
    axes : matplotlib.axes.Axes
    """
    dataframe, rdf = get_plotDF(coolMat, regions, matBalance)
    #print(rdf)
    if logData == True:
        dataframe = np.log2(dataframe)

    N = dataframe.shape[1]

    # Transformation matrix for rotating the heatmap.
    A = np.array([(y, x) for x in range(N, -1, -1) for y in range(N + 1)])
    t = np.array([[1,0.5], [-1,0.5]])
    A = np.dot(A, t)

    C = np.triu(dataframe)
    # -1.0 correlation is blue, 0.0 is white, 1.0 is red.
    #cmap = pl.cm.RdBu_r
    #norm = mp.colors.BoundaryNorm(np.linspace(-1, 1, 14), cmap.N)

    # This MUST be before the call to pl.pcolormesh() to align properly.
    #axes.set_xticks([])
    axes.set_yticks([])

    # Plot the correlation heatmap triangle.
    X = A[:, 1].reshape(N + 1, N + 1)
    Y = A[:, 0].reshape(N + 1, N + 1)

    #caxes = pl.pcolormesh(X, Y, np.fliplr(C), axes=axes, cmap=cmap, norm=norm)

    #norm=MidpointNormalize(midpoint=0,vmin=-1, vmax=1)
    caxes = axes.pcolormesh(X, Y, np.flipud(C), axes=axes, cmap=cmap, edgecolor='none', snap=True, linewidth=.001)
    #caxes = axes.matshow(np.flipud(C), cmap=cmap, norm=norm)

    # Remove the ticks and reset the x limit.

    axes.set_ylim(bottom=0)
    axes.set_xlim(left=0)
    if ymax != None:
        axes.set_ylim(top=ymax)
    axes.set_title(title)
    
    #set_heatmap_ticks(axes)
    
    axes.axis("off")
    #plot_heatmap_triangle_xticks(axes, regin1_mat.shape[1], regin2_mat.shape[1], chrom1, start1, end1, chrom2, start2, end2, showXticks)
    #if ymax==None:
    #    colorbar_bottomright(axes, caxes)
    #else:
    colorbar_triangle(axes, caxes, ymax)
    #plt.show()
    return(rdf["len"], rdf["reverse"])

    #return fig
    #return caxes, D.index

    
def plot_heatmap_triangle_xticks(ax, regin1_binN, regin2_binN, chrom1, start1, end1, chrom2, start2, end2, showXticks):
    #ax.set_xticks([])
    ax.set_xticks([0, regin1_binN, regin1_binN + regin2_binN])
    ax.set_xticklabels([start1, str(end1) + " " + str(start2), end2])
    
    ax.set_yticklabels([])
    ax.set_yticks([])
    
    ax.xaxis.tick_top()
    ax.spines['top'].set_color('k')
    ax.spines['right'].set_color('none')
    ax.spines['bottom'].set_color('none')
    ax.spines['left'].set_color('none')

   
def colorbar_triangle(axm,im,ymax):
    height="2%"
    width="10%"
    if ymax!=None:
        height="6%"
    axins1 = inset_axes(axm, width=width, height=height, loc=4, bbox_to_anchor=(-0.1, 0.7, 1.2, 2.9), bbox_transform=axm.transAxes,)
    cbar=plt.colorbar(im, cax=axins1, orientation='horizontal')
    cbar.ax.xaxis.tick_top()
    cbar.ax.spines['top'].set_color('none')
    cbar.ax.spines['right'].set_color('none')
    cbar.ax.spines['bottom'].set_color('none')
    cbar.ax.spines['left'].set_color('none')

import matplotlib.patches as mpatches
    
def split_region(region):    
    tmp = region.split(":")
    chrom = tmp[0]
    start = tmp[1].split("-")[0]
    end = tmp[1].split("-")[1]
    return(chrom, start, end)
    
def plot_chrom_arrow(ax, region_len, rev_region, regions, colors=my23colors[3:22]):
    ax.axis("off")
    ax.set_xlim(0,sum(region_len))
    ax.set_ylim(-2,2)
    
    start = 0
    for i, v in enumerate(region_len):
        if rev_region[i] == True:
            arrow = mpatches.FancyArrowPatch((start+v+1, 0), (start-1, 0), mutation_scale=30, color=colors[i])
            ax.add_patch(arrow) 
        else:
            arrow = mpatches.FancyArrowPatch((start-1, 0), (start+v+1, 0), mutation_scale=30, color=colors[i])
            ax.add_patch(arrow) 
            
        #ax.add_patch(arrow)    
        chrom, start_str, end_str = split_region(regions[i])
        #ax.text(start+region_len[i]/2, -1.5, chrom, horizontalalignment='center', verticalalignment='top', fontsize=10, color=colors[i])
        ax.text(start+region_len[i]/2, 0, chrom, horizontalalignment='center', verticalalignment='center', fontsize=10, color="black")
        
        ax.text(start, -1.5, start_str, horizontalalignment='left', verticalalignment='top', fontsize=9, color=colors[i], rotation=90)
        ax.text(start+region_len[i], -1.5, end_str, horizontalalignment='right', verticalalignment='top', fontsize=9, color=colors[i], rotation=90)
        start = start + v


    
        

